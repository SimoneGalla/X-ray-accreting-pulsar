import pandas as pd
import os
import matplotlib.pyplot as plt
import numpy as np
from ReadParquet import printKeys, readParquetToDict


def get_float_input(prompt, min_val, max_val):
    """This function assures that the user gives a correct input. The input should be a number that
    lies between a minimum and a maximum value, in order to have physical meaning.
    Parameters:
        ---------
        prompt (string): the input that the user gives to the machine
        min_val (float): the minimum value that is acceptable for the considered parameter
        max_val (float): the maximum value that is acceptable for the considered parameter

    Notes:
        --------
    The while assures us to be in an infinite loop that stops only when the user inputs a correct value for
    the parameter. This function also transforms the input (a string) into a float that can be used for calculations"""
    while True:
        try:
            value = float(input(prompt))
            if min_val <= value <= max_val:
                return value
            else:
                print(f"Please enter a number between {min_val} and {max_val}.")
        except ValueError:
            print("Invalid input. Please enter a number.")


def InputValues():
    """Ask the user 7 different parameters that are needed in order to create the simulated
    pulse profiles of the star. This input data will then be used in order to find the pulse profile
    generated by the closest set of parameters to the input ones

    Returns:
        A dictionary with the 7 input parameters, which has the same keys are the datasets
    """
    input("Hello!!! Press something to start input the data, I am here just to catch you attention")


    # Get user inputs with validation
    rot_i_query = get_float_input("Please, enter the rotation inclination (-90 to 90): ", -90, 90)
    rot_a_query = get_float_input("Enter the rotation azimuth (-180 to 180): ", -180, 180)
    magnc_query = get_float_input("Enter the magnetic colatitude (0 to 90): ", 0, 90)
    p1_query = get_float_input("Enter the beam pattern \"azimuth\" angle (-3.14 to 3.14): ", -3.14, 3.14)
    p2_query = get_float_input("Enter the beam pattern \"inclination\" angle (-3.14 to 3.14): ", -3.14, 3.14)
    p3_query = get_float_input("Enter the beam pattern power (0 to 20): ", 0, 20)
    shift_query = get_float_input("Enter the phase shift (-3.14 to 3.14): ", -3.14, 3.14)
    query = {"rotation inclination": rot_i_query, "rotation azimuth": rot_a_query,
         "magnetic colatitude": magnc_query, "param1": p1_query, "param2": p2_query,
         "param3": p3_query, "shift": shift_query}

    return query


def FilterData(loaded_data, query):
    """Filters the data in the datasets read from the parquet file. The data are iterated over all the keys,
    that correspond to the keys of the input parameters required from the user. Then for every element we compare
    the value corresponding to the key with the input value, and we find the closest ones in the dataset.
    At a successive step we filter out all the data which are not the closest. Repeating this over all the keys wil give back only one last dictionary.

    Parameters:
        --------
        loaded_data (list[dict]): it is the dataset read from the file
        query (dictionary): dictionary of all the input parameters. The keys match the keys of loaded_data

    Returns:
        The closest dictionary from the dataset with respect to the input values, containing also the pulse profile

    Notes:
        -------
    This method might not be the best, but the goal is to make the user understand how to handle the data type that
    is contained in the file. Since it is a list of dictionaries, to use the data we have to be careful about iterating properly and specify both the list index and the dictionary key.
        """
    filtered_data_query = loaded_data.copy()

    # Iterate over each key in the first dictionary, excluding "hotspot pattern"
    for key in list(loaded_data[0].keys()):
        if key != "hotspot pattern":
            minimo_diff = float('inf')
            closest_element = None

            # Find the element with the minimum difference for the current key
            for element in filtered_data_query:
                value = element[key] - query[key]
                if abs(value) < minimo_diff:
                    minimo_diff = abs(value)
                    closest_element = element

            # Filter the list to keep only elements with the minimum value for the current key
            filtered_data_query = [element for element in filtered_data_query if element[key] == closest_element[key]]

            # Update the loaded_data_query to reflect the filtered data for the next iteration
            loaded_data_query = filtered_data_query

    return filtered_data_query[0]

#Ask the user which parameters they want to use
query = InputValues()

### CHANGE WITH YOUR FILEPATH ###

file_name = f'Database_100000'
folder_path = "Database"
file_path = os.path.join(folder_path, file_name)


loaded_data = readParquetToDict(file_path)

#Use the defined function to find the closest dictionary to the input data
closest_data = FilterData(loaded_data, query)

# Print the filtered data
print("The closest simulated data, with corresponding hotspot pattern, to the input parameters are:", closest_data)


#The following lines are just for the plot

x = np.linspace(0, 1, 32)
plt.plot(x, closest_data["hotspot pattern"])
textstr = '\n'.join((
        r'$param1$: %f' % (closest_data["param1"]),
        r'$param2$: %f' % (closest_data["param2"]), r'$param3:%f$' % (closest_data["param3"]),
        r'rotation inclination: %f' % (closest_data["rotation inclination"]),
        r'rotation azimuth: %f' % (closest_data["rotation azimuth"]), r'$shift:%f$' % (closest_data["shift"])))
plt.title("Closest simulated pulse pattern to the given input parameters")
plt.text(0.05, 0.95, textstr, transform=plt.gca().transAxes,
             fontsize=8, verticalalignment='top', bbox=dict(facecolor='green', alpha=0.1))
plt.show()